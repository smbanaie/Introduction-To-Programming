# Module 1: Computers and Programs

## Module Overview

Welcome to the first module of our Introduction to Programming course! This module establishes the fundamental understanding of what computers are, how they work, and how programs run on them. By the end of this module, you'll have a solid conceptual foundation that will help you understand why programming works the way it does.

This module answers the essential questions: What is a computer? How do programs work? Why do computers follow instructions exactly? These concepts are crucial before we dive into writing code.

## Learning Objectives

By the end of this module, you will be able to:

- **Describe** the main components of a computer (CPU, RAM, storage, I/O) and their roles
- **Explain** how programs execute on computers from start to finish
- **Differentiate** between hardware and software
- **Identify** various types of programs in everyday life
- **Understand** why computers follow instructions literally
- **Connect** high-level programming concepts to physical computer operations

## Sessions in This Module

### Session 1: What Is a Computer? How Programs Run
- Computer components and their functions
- Hardware vs software distinction
- Program execution pipeline
- Everyday examples of programs

### Session 2: From Source Code to Machine Code
- Source code vs machine code concepts
- Compilation vs interpretation
- How programming languages work
- Python's execution model

## Key Concepts Covered

### Computer Architecture
- **CPU (Central Processing Unit)**: The "brain" that executes instructions
- **RAM (Memory)**: Temporary storage for running programs
- **Storage**: Long-term data persistence
- **Input/Output Devices**: How humans interact with computers

### Program Execution
- **Source Code**: Human-readable instructions
- **Machine Code**: CPU-executable binary instructions
- **Translation Process**: How code becomes runnable
- **Execution Pipeline**: From program launch to completion

### Programming Foundations
- **Algorithmic Thinking**: Breaking down tasks into steps
- **Literal Execution**: Why precision matters in programming
- **Abstraction Layers**: From human ideas to computer operations

## Why This Module Matters

Before writing code, you need to understand the machine you're programming. This module provides the "why" behind programming:

- **Context**: Understanding computer operations makes programming decisions clearer
- **Debugging**: Knowing how computers work helps troubleshoot issues
- **Performance**: Understanding hardware helps write efficient code
- **Problem-Solving**: Computer knowledge informs algorithmic choices

## Module Activities

### Hands-On Exercises
- Computer component labeling and identification
- Program execution role-playing activities
- Source code to machine code tracing exercises

### Reflection Tasks
- Personal computer usage analysis
- Program identification in daily life
- Hardware/software relationship mapping

## Assessment

This module includes:
- **Concept quizzes** on computer components and program execution
- **Reflection assignments** on personal computing experiences
- **Knowledge checks** on hardware/software relationships

## Prerequisites

- None! This is the starting module of the course
- Basic familiarity with using computers is helpful but not required

## What Comes Next

This module provides the foundation for **Module 2: Digital Information**, where you'll learn how data is represented and stored inside computers. Understanding computer operations will help you grasp why data representation works the way it does.

## Module Resources

### Key Vocabulary
- CPU, RAM, Storage, I/O
- Source code, Machine code
- Hardware, Software
- Compilation, Interpretation

### Further Reading
- "Computer Science: An Interdisciplinary Approach" - Chapter 1
- "How Computers Work" by Ron White
- Khan Academy: Computer Basics

### Extension Activities
- Research the history of computer components
- Compare different computer architectures
- Explore programming language evolution

## Concepts Materials

### Session 1: Computer Fundamentals
This session includes detailed concept articles in the `session-01/concepts/` folder:

#### üîÑ [Process Lifecycle](session-01/concepts/process-lifecycle.md)
- Process creation, execution, and termination
- Process states (New, Ready, Running, Waiting, Terminated)
- Resource management and operating system coordination

#### üß† [Memory Architecture](session-01/concepts/memory-architecture.md)
- RAM, cache memory, and virtual memory systems
- Memory hierarchy and performance optimization
- Memory management and allocation strategies

#### üìÅ [File System](session-01/concepts/file-system.md)
- File system structures and organization
- Directory hierarchies and file operations
- Common file systems (NTFS, APFS, ext4)

#### üî¢ [Binary Format](session-01/concepts/binary-format.md)
- Why computers use binary representation
- Binary operations and data encoding
- Electrical foundations of computing

#### ‚öôÔ∏è [Operating System](session-01/concepts/operating-system.md)
- OS responsibilities and architecture layers
- Boot process and system initialization
- Popular operating systems (Windows, macOS, Linux)

### Session 2: Code Translation and Execution
This session includes detailed concept articles in the `session-02/concepts/` folder:

#### üîÑ [Source Code vs Machine Code vs Bytecode](session-02/concepts/source-machine-bytecode.md)
- Three forms of computer programs
- Human-readable vs CPU-executable code
- Hybrid approaches and their benefits

#### ‚öôÔ∏è [The Compilation Process](session-02/concepts/compilation-process.md)
- Complete compilation pipeline (7 phases)
- Lexical analysis, parsing, and semantic analysis
- Code optimization and generation

#### üé≠ [The Interpretation Process](session-02/concepts/interpretation-process.md)
- Line-by-line code execution
- Different interpreter types and implementations
- Performance characteristics and trade-offs

#### üèóÔ∏è [Programming Language Paradigms](session-02/concepts/programming-paradigms.md)
- Imperative, functional, object-oriented programming
- Logic programming and declarative approaches
- Paradigm selection and modern multi-paradigm languages

#### üêç [Python's Execution Model](session-02/concepts/python-execution-model.md)
- Python's hybrid compilation + interpretation approach
- Bytecode generation and the Python Virtual Machine
- Memory management and performance characteristics

---

**Module Progress**: 2 sessions ‚Ä¢ Estimated Time: 4-6 hours
**Next**: Module 2: Digital Information