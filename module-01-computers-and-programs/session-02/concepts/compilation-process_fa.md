# فرآیند کامپایل: تبدیل منبع به کد ماشین

## کامپایل چیست؟

**کامپایل** فرآیند ترجمه کد منبع قابل خواندن توسط انسان به کد ماشین است که کامپیوترها می‌توانند اجرا کنند. مانند تبدیل یک دستور پخت نوشته شده به زبان انگلیسی به دستورالعمل‌های مرحله به مرحله برای یک ربات آشپز.

## خط لوله کامپایل

### مرحله ۱: تحلیل لغوی (اسکن)
**ورودی**: متن کد منبع
**خروجی**: جریان توکن‌ها
**هدف**: کد را به واحدهای معنادار تقسیم کند

```
منبع: if (x > 5) return true;
توکن‌ها: if, (, x, >, 5, ), return, true, ;
```

**چه اتفاقی می‌افتد:**
- فضای خالی و کامنت‌ها را حذف می‌کند
- کلمات کلیدی را شناسایی می‌کند (if, while, class)
- عملگرها را تشخیص می‌دهد (+, -, >, ==)
- لیترال‌ها را دسته‌بندی می‌کند ("hello", 42, 3.14)

### مرحله ۲: تحلیل نحوی (پارسینگ)
**ورودی**: جریان توکن‌ها
**خروجی**: درخت نحوی انتزاعی (AST)
**هدف**: گرامر و ساختار را بررسی کند

```
if (x > 5) return true;

درخت نحوی انتزاعی:
├── IfStatement
│   ├── Condition: BinaryExpression (>)
│   │   ├── Left: Identifier (x)
│   │   └── Right: NumberLiteral (5)
│   └── ThenBranch: ReturnStatement
│       └── Expression: BooleanLiteral (true)
```

**چه اتفاقی می‌افتد:**
- قوانین نحوی را تأیید می‌کند
- ساختار سلسله مراتبی می‌سازد
- خطاهای نحوی را تشخیص می‌دهد
- جدول نماد را ایجاد می‌کند (متغیرها، توابع)

### مرحله ۳: تحلیل معنایی
**ورودی**: AST
**خروجی**: AST دارای حاشیه نویسی
**هدف**: معنی و منطق را بررسی کند

**بررسی‌هایی که انجام می‌دهد:**
- اعلام متغیرها در مقابل استفاده
- سازگاری نوع
- فراخوانی توابع مطابق با تعریف‌ها
- قوانین حوزه (محلی در مقابل جهانی)

### مرحله ۴: تولید کد میانی
**ورودی**: AST حاشیه نویسی شده
**خروجی**: نمایش میانی (IR)
**هدف**: بهینه‌سازی مستقل از پلتفرم

**چرا میانی؟**
- از کد منبع برای بهینه‌سازی آسان‌تر است
- از AST برای تولید کد ماشین آسان‌تر است
- امکان کامپایل متقابل را فراهم می‌کند

**IR مثال (کد سه آدرسه):**
```
t1 = x > 5
if t1 goto L1
goto L2
L1: return true
L2: ...
```

### مرحله ۵: بهینه‌سازی کد
**ورودی**: کد میانی
**خروجی**: کد میانی بهینه‌سازی شده
**هدف**: عملکرد و اندازه را بهبود بخشد

**انواع بهینه‌سازی:**

#### بهینه‌سازی محلی (درون توابع)
```c
// قبل از بهینه‌سازی
x = y + 0;        // اضافه کردن صفر (بی‌فایده)
if (true) {       // همیشه درست
    statement;
}

// بعد از بهینه‌سازی
x = y;            // ساده‌سازی شده
statement;        // شرط غیرضروری حذف شده
```

#### بهینه‌سازی جهانی (میان توابع)
- **تا کردن ثابت**: `2 * 3.14159` → `6.28318`
- **حذف کد مرده**: کد غیرقابل دسترسی را حذف کند
- **درون‌سازی تابع**: فراخوانی توابع را با کد جایگزین کند
- **بهینه‌سازی حلقه**: متغیرهای ثابت را خارج از حلقه ببرد

### مرحله ۶: تولید کد
**ورودی**: کد میانی بهینه‌سازی شده
**خروجی**: کد ماشین
**هدف**: دستورالعمل‌های اجرایی تولید کند

**کارهای وابسته به هدف:**
- تخصیص ثبات (از کدام ثبات‌های CPU استفاده کند)
- انتخاب دستورالعمل (بهترین دستورالعمل‌های CPU)
- تخصیص آدرس (مکان‌های حافظه)
- بهینه‌سازی peep hole (بهبودهای محلی)

### مرحله ۷: لینک
**ورودی**: فایل‌های شیء متعدد
**خروجی**: برنامه اجرایی
**هدف**: قطعات جداگانه را ترکیب کند

**چه چیزی لینک می‌شود:**
- کد کامپایل شده شما
- توابع کتابخانه استاندارد (printf, malloc)
- کتابخانه‌های خارجی (گرافیک، شبکه)
- فراخوانی توابع میان فایل‌ها را حل کند

## کامپایل در برابر تفسیر

### مزایای کامپایل
- **عملکرد**: بدون سربار ترجمه زمان اجرا
- **قابل توزیع**: اجرایی روی هر کامپیوتر سازگار اجرا شود
- **بررسی خطای بهتر**: همه خطاها قبل از اجرا یافت شوند
- **شروع سریع**: پس از کامپایل اولیه

### معایب کامپایل
- **چرخه توسعه**: ویرایش → کامپایل → تست → اشکال‌زدایی → ویرایش → کامپایل...
- **وابستگی به پلتفرم**: باینری‌های مختلف برای هر پلتفرم
- **اشکال‌زدایی**: خطاها به کد ماشین اشاره دارند، نه منبع
- **زمان کامپایل**: کامپایل اولیه می‌تواند کند باشد

### چه زمانی از کامپایل استفاده کنیم
- **برنامه‌های حیاتی عملکرد**: بازی‌ها، محاسبات علمی
- **سیستم‌های embedded**: منابع محدود، نیازهای زمان واقعی
- **توزیع**: وقتی بخواهید منبع را مخفی کنید
- **برنامه‌های بزرگ**: از بهینه‌سازی گسترده بهره ببرند

## خطاهای رایج کامپایل

### خطاهای نحوی
```c
if (x > 5) {        // آکولاد بسته فراموش شده
```
**خطا**: `expected '}' at end of input`

### خطاهای معنایی
```c
int x = "hello";    // نوع اشتباه
```
**خطا**: `incompatible types in assignment`

### خطاهای لینکر
```c
extern void missing_function();  // اعلام شده اما تعریف نشده
```
**خطا**: `undefined reference to 'missing_function'`

## معماری کامپایلر

### فرانت‌اند
- **وابسته به زبان**: lexing، parsing، تحلیل معنایی
- **مستقل از هدف**: برای هر معماری CPU کار می‌کند

### میدل‌اند (بهینه‌ساز)
- **مستقل از زبان**: روی نمایش میانی کار می‌کند
- **مستقل از پلتفرم**: بهینه‌سازی‌ها همه جا اعمال می‌شوند

### بک‌اند
- **وابسته به هدف**: تولید کد برای CPU خاص
- **آگاه از سخت‌افزار**: از قابلیت‌های CPU هدف استفاده می‌کند

## نکات کلیدی

۱. **کامپایل کد منبع را به کد ماشین ترجمه می‌کند** از طریق مراحل متعدد
۲. **هر مرحله هدفی خاص دارد** در خط لوله ترجمه
۳. **بهینه‌سازی عملکرد را بهبود می‌بخشد** از طریق تحلیل و تبدیل
۴. **زبان‌های مختلف استراتژی‌های کامپایل متفاوتی دارند**
۵. **سیستم‌های مدرن کامپایل و تفسیر را ترکیب می‌کنند** برای بهترین نتایج

## تأثیر عملکرد

### مبادلات زمان کامپایل
- **ساخت‌های debug**: کامپایل سریع، بهینه‌سازی کمتر
- **ساخت‌های release**: کامپایل کند، حداکثر بهینه‌سازی
- **ساخت‌های incremental**: فقط فایل‌های تغییر یافته را کامپایل کند

### عملکرد زمان اجرا
- **زبان‌های کامپایل شده**: عملکرد نزدیک به بهینه
- **زبان‌های تفسیر شده**: کندتر اما انعطاف‌پذیرتر
- **زبان‌های JIT**: شروع کند، بهتر می‌شوند با زمان

## مطالعه بیشتر
- ساخت کامپایلر را مطالعه کنید
- تکنیک‌های کامپایل JIT را بیاموزید
- LLVM (زیرساخت کامپایلر) را کاوش کنید
- سیستم‌های ساخت (Make, CMake, Ninja) را درک کنید