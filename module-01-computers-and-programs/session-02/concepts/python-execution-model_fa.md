# مدل اجرای Python: چگونه کد Python واقعاً اجرا می‌شود

## رویکرد ترکیبی Python

Python از ترکیب منحصر به فرد کامپایل و تفسیر استفاده می‌کند که بهترین هر دو دنیا را به آن می‌دهد. درک این مدل کمک می‌کند توضیح دهیم چرا Python به این شکل کار می‌کند.

## خط لوله اجرا

### مرحله ۱: کد منبع (.py)
شما کد Python قابل خواندن توسط انسان می‌نویسید:

```python
def greet(name):
    return f"سلام، {name}!"

message = greet("علی")
print(message)
```

### مرحله ۲: کامپایل به بایت‌کد (.pyc)
Python کد منبع شما را به بایت‌کد کامپایل می‌کند:

```
کد منبع Python (.py) → کامپایلر Python → بایت‌کد (.pyc)
```

**چه اتفاقی می‌افتد:**
- **تحلیل لغوی**: کد را به توکن‌ها تقسیم کن
- **پارسینگ**: درخت نحوی انتزاعی ایجاد کن
- **تولید بایت‌کد**: به بایت‌کد Python تبدیل کن
- **کش کردن**: فایل .pyc را برای اجرای آینده ذخیره کن

### مرحله ۳: ماشین مجازی Python (PVM)
ماشین مجازی Python بایت‌کد را اجرا می‌کند:

```
بایت‌کد (.pyc) → ماشین مجازی Python → اجرای CPU
```

**چه اتفاقی می‌افتد:**
- **اجرای مبتنی بر پشته**: از پشته برای عملیات استفاده کن
- **تایپ پویا**: متغیرها می‌توانند نوع خود را در زمان اجرا تغییر دهند
- **زباله‌روبی**: مدیریت خودکار حافظه
- **مدیریت خطا**: استثناها به سمت بالا انتشار می‌یابند

## غواصی عمیق در بایت‌کد

### بایت‌کد Python چیست؟

بایت‌کد نمایش میانی Python است - نه کد ماشین، اما نه کد منبع هم.

**ویژگی‌ها:**
- **مستقل از پلتفرم**: همان بایت‌کد روی هر نصب Python اجرا می‌شود
- **فشرده**: کارآمدتر از کد منبع
- **غیرقابل اجرا مستقیم**: نیاز به ماشین مجازی دارد
- **وابسته به نسخه**: بایت‌کد از Python ۳.۸ روی Python ۳.۹ اجرا نمی‌شود

### نمایش بایت‌کد

می‌توانید بایت‌کد Python را با استفاده از ماژول `dis` بررسی کنید:

```python
import dis

def add_numbers(a, b):
    return a + b

# تابع را disassemble کن
dis.dis(add_numbers)
```

**خروجی:**
```
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 BINARY_ADD
              6 RETURN_VALUE
```

### درک دستورالعمل‌های بایت‌کد

| دستورالعمل | معنی | تأثیر پشته |
|-------------|------|------------|
| `LOAD_FAST` | متغیر محلی را بارگذاری کن | مقدار را push کن |
| `BINARY_ADD` | دو مقدار بالای پشته را جمع کن | ۲ pop، ۱ push |
| `RETURN_VALUE` | از تابع بازگرد | pop و return |
| `LOAD_CONST` | مقدار ثابت را بارگذاری کن | مقدار را push کن |
| `CALL_FUNCTION` | تابع را فراخوانی کن | پیچیده |

## مفسر Python (CPython)

### CPython چیست؟
CPython پیاده‌سازی مرجع Python است که به زبان C نوشته شده.

**معماری:**
- **پارس**: کد منبع را به AST تبدیل کن
- **کامپایلر**: AST را به بایت‌کد تبدیل کن
- **ماشین مجازی**: بایت‌کد را اجرا کن
- **کتابخانه استاندارد**: ماژول‌های داخلی و توابع

### مؤلفه‌های کلیدی

#### پارس
- **ورودی**: متن کد منبع
- **خروجی**: درخت نحوی انتزاعی (AST)
- **مدیریت خطا**: خطاهای نحوی را کشف کن

#### کامپایلر
- **ورودی**: AST
- **خروجی**: اشیاء کد با بایت‌کد
- **بهینه‌سازی**: بهینه‌سازی‌های پایه اعمال کن

#### ماشین مجازی
- **ورودی**: اشیاء کد
- **اجرا**: تفسیر بایت‌کد مبتنی بر پشته
- **حافظه**: اشیاء Python را مدیریت کن و ارجاع بده

## مدیریت حافظه

### مدل شیء Python
- **هر چیزی شیء است**: اعداد، رشته‌ها، توابع، کلاس‌ها
- **شمارش ارجاع**: اشیاء تعداد ارجاع‌ها را پیگیری می‌کنند
- **زباله‌روبی**: پاکسازی خودکار اشیاء استفاده نشده
- **تایپ پویا**: متغیرها فقط ارجاع به اشیاء نگه می‌دارند

### وضوح متغیر
```python
x = 42

# در داخل:
# ۱. شیء عدد صحیح با مقدار ۴۲ ایجاد کن
# ۲. متغیر x را ایجاد کن که به آن شیء اشاره کند
# ۳. شمارش ارجاع را افزایش بده
```

### فراخوانی توابع
```python
def greet(name):
    return f"Hello, {name}!"

result = greet("Alice")

# مراحل اجرا:
# ۱. شیء تابع برای greet() ایجاد کن
# ۲. آرگومان‌ها را روی پشته push کن
# ۳. بایت‌کد تابع را اجرا کن
# ۴. مقدار بازگشتی را pop کن
# ۵. در متغیر result ذخیره کن
```

## سیستم import

### چگونه import کار می‌کند
```python
import math

# پشت صحنه:
# ۱. بررسی کن آیا math.pyc وجود دارد و به‌روز است
# ۲. اگر نه، math.py را به math.pyc کامپایل کن
# ۳. بایت‌کد را در حافظه بارگذاری کن
# ۴. شیء ماژول ایجاد کن
# ۵. کد سطح ماژول را اجرا کن
# ۶. در sys.modules کش ذخیره کن
```

### فرآیند بارگذاری ماژول
۱. **ماژول را پیدا کن**: دایرکتوری‌های sys.path را جستجو کن
۲. **بایت‌کد را بارگذاری کن**: در صورت نیاز کامپایل کن
۳. **ماژول را اجرا کن**: کد سطح بالا را اجرا کن
۴. **فضای نام ایجاد کن**: ویژگی‌های ماژول را در دسترس قرار بده
۵. **نتیجه را کش کن**: در sys.modules ذخیره کن

## ویژگی‌های عملکرد

### نقاط قوت
- **شروع سریع**: کش بایت‌کد از کامپایل مجدد جلوگیری می‌کند
- **مستقل از پلتفرم**: منبع یکسان همه جا اجرا شود
- **ویژگی‌های پویا**: بازتاب و تغییر آسان
- **اکوسیستم غنی**: کتابخانه استاندارد گسترده

### محدودیت‌ها
- **قفل مفسر جهانی (GIL)**: استفاده از چند هسته را محدود می‌کند
- **سربار حافظه**: همه چیز شیء است
- **سربار تفسیر**: اجرای بایت‌کد کندتر از کد ماشین است

### تکنیک‌های بهینه‌سازی
- **PyPy**: کامپایلر JIT برای عملکرد بهتر
- **Cython**: Python را به C کامپایل کن برای سرعت
- **NumPy**: کتابخانه‌های C بهینه‌سازی شده برای محاسبات عددی
- **چندپردازشی**: GIL را برای کد حیاتی CPU دور بزن

## مدیریت خطا و اشکال‌زدایی

### انتشار استثنا
```python
def divide(a, b):
    return a / b

try:
    result = divide(10, 0)
except ZeroDivisionError as e:
    print(f"خطا: {e}")

# پشت صحنه:
# ۱. ZeroDivisionError در divide() ایجاد شود
# ۲. استثنا به سمت بالا انتشار یابد
# ۳. توسط بند except در فراخواننده گرفته شود
# ۴. شیء استثنا با traceback ایجاد شود
```

### ابزارهای اشکال‌زدایی
- **pdb**: اشکال‌زدای Python برای قدم زدن در کد
- **trace**: اجرای و فراخوانی توابع را ردگیری کن
- **cProfile**: گلوگاه‌های عملکرد را پروفایل کن
- **sys.settrace()**: توابع ردگیری سفارشی

## Python در برابر زبان‌های دیگر

### در مقایسه با زبان‌های کامپایل شده (C++, Java)
```
Python: منبع → بایت‌کد → VM → CPU
C++:     منبع → کامپایلر → کد ماشین → CPU
Java:    منبع → بایت‌کد → JVM → CPU
```

### تفاوت‌های کلیدی
- **Python**: تفسیر با کش بایت‌کد
- **C++**: کاملاً به کد ماشین کامپایل شده
- **Java**: به بایت‌کد کامپایل شده، JIT در زمان اجرا

## دلالت‌های دنیای واقعی

### گردش کار توسعه
- **تکرار سریع**: بدون مرحله کامپایل
- **توسعه تعاملی**: REPL برای آزمایش
- **توزیع آسان**: فقط فایل‌های .py را کپی کن

### ملاحظات عملکرد
- **محدود I/O**: Python در سرورهای وب، پردازش فایل خوب عمل می‌کند
- **محدود CPU**: ممکن است برای کد حیاتی عملکرد نیاز به بهینه‌سازی داشته باشد
- **استفاده از حافظه**: سربار بالاتر از زبان‌های کامپایل شده

### مزایای اکوسیستم
- **مدیریت بسته**: pip بسته‌های پیش کامپایل شده نصب می‌کند
- **cross-platform**: بنویس یک بار، همه جا اجرا کن
- **جامعه**: اکوسیستم کتابخانه عظیم

## نکات کلیدی

۱. **Python از کامپایل بایت‌کد برای عملکرد استفاده می‌کند** با انعطاف‌پذیری تفسیر
۲. **ماشین مجازی بایت‌کد را اجرا می‌کند** استقلال از پلتفرم را فراهم می‌کند
۳. **ویژگی‌های پویا** امکان بازتاب و تغییر قدرتمند را فراهم می‌کنند
۴. **مدیریت حافظه خودکار است** با شمارش ارجاع
۵. **سیستم import ماژول‌ها را بارگذاری و کش می‌کند**
۶. **معاوضات عملکرد** با سهولت توسعه متعادل شده

## تصورات غلط رایج

### "Python کاملاً تفسیر شده است"
**واقعیت**: Python به بایت‌کد کامپایل می‌شود، سپس تفسیر می‌شود

### "بایت‌کد Python کد ماشین است"
**واقعیت**: بایت‌کد مخصوص Python است، نیاز به PVM دارد تا اجرا شود

### "Python کند است"
**واقعیت**: بایت‌کد Python کارآمد است، گلوگاه‌ها معمولاً در کد کاربر هستند

### "Python نمی‌تواند سریع باشد"
**واقعیت**: PyPy، Cython و کد نویسی مراقب می‌تواند Python را بسیار سریع کند

## مطالعه بیشتر
- مدل داده Python و سیستم شیء را مطالعه کنید
- درباره قفل مفسر جهانی (GIL) بیاموزید
- پیاده‌سازی‌های جایگزین Python (PyPy, Jython, IronPython) را کاوش کنید
- سیستم import و بارگذاری ماژول Python را درک کنید